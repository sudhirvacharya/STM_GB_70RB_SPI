#include <stdint.h>
#include "stm32g0xx.h"
#include<stdbool.h>


/*
 * PA6->MISO, PA7->MOSI, PA1->SCK, PA7->NSS
 */

#define MAX_RDATA 100
uint32_t ID = 0;
uint8_t rdata[MAX_RDATA];
uint8_t buff[16];
uint8_t currIdx;
uint8_t checkIdx;



#define MAX7219_REG_NO_OP        0x00
#define MAX7219_REG_DIGIT0       0x01
#define MAX7219_REG_DIGIT1       0x02
#define MAX7219_REG_DIGIT2       0x03
#define MAX7219_REG_DIGIT3       0x04
#define MAX7219_REG_DIGIT4       0x05
#define MAX7219_REG_DIGIT5       0x06
#define MAX7219_REG_DIGIT6       0x07
#define MAX7219_REG_DIGIT7       0x08
#define MAX7219_REG_DECODE_MODE  0x09
#define MAX7219_REG_INTENSITY    0x0A
#define MAX7219_REG_SCAN_LIMIT   0x0B
#define MAX7219_REG_SHUTDOWN     0x0C
#define MAX7219_REG_DISPLAY_TEST 0x0F

const uint8_t digit[][9]= {
		 {
		    0b00000000, //dummy at index 0 , NOP
			0b11111111, //digit 0
			0b10000001,
			0b10000001,
			0b10000001,
			0b10000001,
			0b10000001,
			0b10000001,
			0b11111111  //digit 7
		 },
		 {
		    0b00000000, //dummy at index 0
		 	0b00000000,
		 	0b00000000,
		 	0b00000000,
		 	0b00000000,
		 	0b00000000,
		 	0b00000000,
		 	0b00000000,
			0b11111111
		 		 }

     };

/******SysTick ******/

static volatile uint32_t timeDelay=0;
//volatile int32_t clockfreqinKhz=16000;//as for 10ms SysTick interval
volatile int32_t csrRegister;
uint32_t timeout;
#define POLLING 1
#define MAXCOUNT 50000

void SysTick_initialize(uint32_t clockFreqinKhz)
{
    SysTick->LOAD=clockFreqinKhz-1;
    SysTick->VAL=0x0;
    SysTick->CTRL=0x4;//Processor clock
#if !POLLING
    SysTick->CTRL |=0x2;
#endif
    SysTick->CTRL |=0x1;
}

void updateTimeDelay(void){
#if POLLING
	csrRegister=SysTick->CTRL;
#endif
	csrRegister &= (1<<16);
	if(csrRegister){
		timeDelay++;
     if(timeout > 0) timeout--;
	}
}

void delay1ms(uint8_t nmsecs)
{
  timeDelay=0;
  while(timeDelay != nmsecs)
     updateTimeDelay();
}


void delay(uint32_t k)
{
	uint32_t i, j;
	for(i=0; i<=j; i++)
		for(j=0; j<=1000; j++);
}
//Generic code for GPIO
void set_GPIO_mode(char port , uint8_t pin , uint8_t mode )
{
	switch (port)
	{
		case 'A':
			#ifdef STM32F072xB
				RCC->AHBENR |= (1<<17);
			#elif defined STM32G071xx
				RCC->IOPENR |= (1<<0);
			#endif
				GPIOA->MODER &= ~(3 << (pin*2));
				GPIOA->MODER |= (mode << (pin*2));
			break;
		case 'B':
			#ifdef STM32F072xB
				RCC->AHBENR |= (1 << 18);
			#elif defined STM32G071xx
				RCC->IOPENR |= (1<<1);
			#endif
			GPIOB->MODER &= ~(3 << (pin*2));
			GPIOB->MODER |= (mode << (pin*2));
			break;
		case 'C':
			#ifdef STM32F072xB
				RCC->AHBENR |= (1 << 19);
			#elif defined STM32G071xx
				RCC->IOPENR |= (1<<2);
			#endif
			GPIOC->MODER &= ~(3 << (pin*2));
			GPIOC->MODER |= (mode << (pin*2));
			break;

		default:
			break;

    }
}




void config_PLL()
{
	uint32_t pllStatus =0;

    RCC->CR |= (1<<8) ;//HSI on
	while (!(RCC->CR &(1 <<10)));

	FLASH->ACR |= (2<<0); //To adjust with new frequency
    while( ((FLASH->ACR) & (7<<0)) != 0x02);

    RCC->CR &= (~(1<< 24)); //Disable main PLL
	while(RCC->CR & (1<<25));

	RCC->PLLCFGR = (2 <<0); //HSI16
  //RCC->PLLCFGR |= (2 << 4); //M=2 , 16/4=4Mhz input to PLL
	RCC->PLLCFGR |= (8<< 8); //N=8 , 128MHz PLL output
	RCC->PLLCFGR |= (1<< 17); //P=2  ,32/2=16mhz
    RCC->PLLCFGR |= (1<< 29); //R=2  ,128/2=64mhz
	RCC->PLLCFGR |= (1<< 25); //Q=2  ,32/2=16mhz

	RCC->CR |= (1<< 24); //PLLEN
	do
    {
		pllStatus = RCC->CR ;
		pllStatus &= (1<< 25);
    }while (!pllStatus);
	RCC->PLLCFGR |= (1<< 28); //PLLR EN

#if MCO_OUT
      //MCO out
	   set_GPIO_mode('A',8,2);
	   GPIOA->AFR[1] &= (~(0xF<<0)); //Alternate function for PA8
       RCC->CFGR |= (4 << 28); // MCO divide by 16
	   RCC->CFGR |= (1 << 24); // 1 is SYSCLK,  3 is HSI16, 5 is Connect PLLRCLK to MCO
#endif
    RCC->CFGR |= (2 <<0); //PLLRCLK as SYSCLK  If you change freq from 1 to 4Mhz , â€¦
